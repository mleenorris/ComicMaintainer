<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comic Maintainer - Web Interface</title>
    <style>
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: white;
            --bg-tertiary: #ecf0f1;
            --bg-header: #2c3e50;
            --bg-hover: #f8f9fa;
            --bg-hover-alt: #e9ecef;
            --bg-indented: #fafafa;
            --bg-indented-hover: #f0f0f0;
            
            --text-primary: #333;
            --text-secondary: #2c3e50;
            --text-muted: #7f8c8d;
            --text-light: #95a5a6;
            --text-header: white;
            
            --border-primary: #ecf0f1;
            --border-secondary: #bdc3c7;
            --border-tertiary: #e0e0e0;
            --border-input: #ddd;
            
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.3);
            
            --modal-overlay: rgba(0,0,0,0.5);
        }
        
        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --bg-header: #1f2937;
            --bg-hover: #3a3a3a;
            --bg-hover-alt: #404040;
            --bg-indented: #252525;
            --bg-indented-hover: #303030;
            
            --text-primary: #e5e5e5;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --text-light: #6b7280;
            --text-header: white;
            
            --border-primary: #404040;
            --border-secondary: #4a4a4a;
            --border-tertiary: #3a3a3a;
            --border-input: #4a4a4a;
            
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.5);
            
            --modal-overlay: rgba(0,0,0,0.7);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: var(--bg-header);
            color: var(--text-header);
            padding: 12px 20px;
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 100;
            overflow: visible;
        }
        
        .header .container {
            overflow: visible;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left h1 {
            margin-bottom: 2px;
            font-size: 24px;
        }
        
        .header-left p {
            font-size: 13px;
            opacity: 0.9;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-search {
            position: relative;
        }
        
        .header-search input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-header);
            font-size: 13px;
            width: 200px;
            transition: all 0.3s;
        }
        
        .header-search input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .header-search input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .header-filter-dropdown {
            position: relative;
        }
        
        .header-filter-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-header);
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .header-filter-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .header-filter-toggle::after {
            content: '▼';
            font-size: 9px;
        }
        
        .header-sort-dropdown {
            position: relative;
        }
        
        .header-sort-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-header);
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .header-sort-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .header-sort-toggle::after {
            content: '▼';
            font-size: 9px;
        }
        
        .header-dropdown-menu {
            display: none;
            position: absolute;
            right: 0;
            top: calc(100% + 5px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 5px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            min-width: 180px;
            overflow: hidden;
        }
        
        .header-dropdown-menu.show {
            display: block;
        }
        
        .header-dropdown-item {
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 13px;
            color: var(--text-primary);
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: inherit;
        }
        
        .header-dropdown-item:hover {
            background: var(--bg-hover);
        }
        
        .header-dropdown-item.active {
            background: #3498db;
            color: white;
            font-weight: 500;
        }
        
        .settings-menu-wrapper {
            position: relative;
        }
        
        .settings-menu-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-header);
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .settings-menu-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .settings-dropdown-menu {
            display: none;
            position: absolute;
            left: 0;
            top: calc(100% + 5px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 5px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            min-width: 200px;
            overflow: hidden;
        }
        
        .settings-dropdown-menu.show {
            display: block;
        }
        
        .settings-dropdown-item {
            padding: 12px 15px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
            color: var(--text-primary);
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: inherit;
        }
        
        .settings-dropdown-item:hover {
            background: var(--bg-hover);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .controls-wrapper {
            flex-shrink: 0;
        }
        
        .content-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }
        
        .actions-bar {
            background: var(--bg-secondary);
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .search-bar {
            background: var(--bg-secondary);
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
        }
        
        .search-bar-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .search-bar input {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid var(--border-input);
            border-radius: 5px;
            font-size: 14px;
            font-family: inherit;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: border-color 0.3s;
        }
        
        .search-bar input:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .filter-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .filter-dropdown-toggle {
            background: var(--bg-primary);
            border: 1px solid var(--border-input);
            color: var(--text-primary);
            padding: 12px 15px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            transition: all 0.3s;
            font-family: inherit;
            font-weight: 500;
        }
        
        .filter-dropdown-toggle:hover {
            background: var(--bg-hover);
            border-color: #3498db;
        }
        
        .filter-dropdown-toggle::after {
            content: '▼';
            font-size: 10px;
            margin-left: 5px;
        }
        
        .filter-dropdown-menu {
            display: none;
            position: absolute;
            right: 0;
            top: calc(100% + 5px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 5px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            min-width: 180px;
            overflow: hidden;
        }
        
        .filter-dropdown-menu.show {
            display: block;
        }
        
        .filter-dropdown-item {
            padding: 12px 15px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
            color: var(--text-primary);
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: inherit;
        }
        
        .filter-dropdown-item:hover {
            background: var(--bg-hover);
        }
        
        .filter-dropdown-item.active {
            background: #3498db;
            color: white;
            font-weight: 500;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
        }
        
        .btn-success {
            background: #27ae60;
            color: white;
        }
        
        .btn-success:hover {
            background: #229954;
        }
        
        .btn-warning {
            background: #f39c12;
            color: white;
        }
        
        .btn-warning:hover {
            background: #d68910;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-rename {
            background: #9b59b6;
            color: white;
        }
        
        .btn-rename:hover {
            background: #8e44ad;
        }
        
        .btn-normalize {
            background: #16a085;
            color: white;
        }
        
        .btn-normalize:hover {
            background: #138d75;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .button-group .btn {
            padding: 8px 12px;
            font-size: 13px;
        }
        
        .file-list {
            background: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }
        
        .file-list-header {
            background: var(--bg-tertiary);
            padding: 15px;
            font-weight: 600;
            display: grid;
            grid-template-columns: 30px 40px 1fr 150px 240px;
            gap: 10px;
            border-bottom: 2px solid var(--border-secondary);
            align-items: center;
        }
        
        .toggle-all-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 16px;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            border-radius: 3px;
        }
        
        .toggle-all-btn:hover {
            background: var(--bg-hover);
        }
        
        .directory-header {
            padding: 12px 15px;
            background: var(--bg-hover);
            border-bottom: 1px solid var(--border-tertiary);
            font-weight: 600;
            color: var(--text-secondary);
            display: grid;
            grid-template-columns: 40px 1fr;
            gap: 10px;
            align-items: center;
            user-select: none;
            transition: background 0.2s;
        }
        
        .directory-header-clickable {
            cursor: pointer;
            display: grid;
            grid-template-columns: 16px 16px 1fr 150px;
            gap: 8px;
            align-items: center;
        }
        
        .directory-header:hover {
            background: var(--bg-hover-alt);
        }
        
        .directory-toggle {
            font-size: 12px;
            transition: transform 0.2s;
            display: inline-block;
            width: 16px;
            flex-shrink: 0;
        }
        
        .directory-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .directory-icon {
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .directory-path {
            font-size: 14px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .directory-file-count {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: normal;
            text-align: right;
        }
        
        .directory-checkbox {
            justify-self: center;
        }
        
        .directory-content {
            display: block;
        }
        
        .directory-content.collapsed {
            display: none;
        }
        
        .file-item {
            padding: 15px;
            padding-left: 45px;
            display: grid;
            grid-template-columns: 40px 1fr 150px 240px;
            gap: 10px;
            border-bottom: 1px solid var(--border-primary);
            align-items: center;
            transition: background 0.2s;
        }
        
        .file-item.indented {
            padding-left: 65px;
            background: var(--bg-indented);
        }
        
        .file-item:hover {
            background: var(--bg-hover);
        }
        
        .file-item.indented:hover {
            background: var(--bg-indented-hover);
        }
        
        .file-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .file-name {
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        .file-path {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 3px;
        }
        
        .file-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .btn-small {
            padding: 5px 12px;
            font-size: 12px;
        }
        
        .file-actions-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            padding: 5px 12px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }
        
        .dropdown-toggle:hover {
            background: var(--bg-hover);
            border-color: var(--border-primary);
        }
        
        .dropdown-toggle::after {
            content: '▼';
            font-size: 10px;
        }
        
        .dropdown-menu {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            box-shadow: var(--shadow-md);
            z-index: 100;
            min-width: 150px;
            margin-top: 2px;
        }
        
        .dropdown-menu.show {
            display: block;
        }
        
        .dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 12px;
            color: var(--text-primary);
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .dropdown-item:hover {
            background: var(--bg-hover);
        }
        
        .dropdown-item:first-child {
            border-radius: 4px 4px 0 0;
        }
        
        .dropdown-item:last-child {
            border-radius: 0 0 4px 4px;
        }
        
        .dropdown-divider {
            height: 1px;
            background: var(--border-primary);
            margin: 4px 0;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-overlay);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 8px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-md);
        }
        
        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            color: var(--text-primary);
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-light);
        }
        
        .close-btn:hover {
            color: var(--text-muted);
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-input);
            border-radius: 5px;
            font-size: 14px;
            font-family: inherit;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .form-group code {
            background: var(--bg-hover);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .modal-footer {
            padding: 20px;
            border-top: 1px solid var(--border-primary);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar-container {
            width: 100%;
            height: 24px;
            background: var(--bg-hover);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border-primary);
        }
        
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.3s ease;
            width: 0%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
        
        .message {
            padding: 12px 20px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .select-info {
            margin-left: auto;
            color: var(--text-muted);
            font-size: 14px;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-light);
        }
        
        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            margin-top: 15px;
            flex-shrink: 0;
        }
        
        .page-info {
            color: var(--text-muted);
            font-size: 14px;
            min-width: 100px;
            text-align: center;
        }
        
        /* Intermediate Desktop Responsive Styles (Tablets & Small Desktops) */
        @media (max-width: 1024px) and (min-width: 769px) {
            .header {
                padding: 10px 15px;
            }
            
            .header h1 {
                font-size: 22px;
            }
            
            .header p {
                font-size: 12px;
            }
            
            .header-search input {
                width: 180px;
            }
            
            .btn {
                padding: 9px 16px;
                font-size: 13px;
            }
            
            .select-info {
                flex-basis: 100%;
                text-align: center;
                margin-left: 0;
                margin-top: 8px;
            }
            
            .file-list-header {
                grid-template-columns: 30px 40px 1fr 120px 200px;
            }
            
            .file-item {
                grid-template-columns: 40px 1fr 120px 200px;
                margin-left: 30px;
            }
            
            .directory-header {
                grid-template-columns: 40px 1fr;
            }
            
            .directory-header-clickable {
                grid-template-columns: 16px 16px 1fr 120px;
            }
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            body {
                height: 100vh;
                height: 100dvh; /* Use dynamic viewport height on mobile */
            }
            
            .container {
                padding: 10px;
            }
            
            .header {
                padding: 10px;
            }
            
            .header-content {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
            
            .header h1 {
                font-size: 20px;
            }
            
            .header p {
                font-size: 12px;
                display: none;
            }
            
            .header-right {
                width: 100%;
                justify-content: space-between;
            }
            
            .header-controls {
                flex: 1;
                gap: 6px;
            }
            
            .header-search {
                flex: 1;
            }
            
            .header-search input {
                width: 100%;
                padding: 8px 10px;
                font-size: 12px;
            }
            
            .header-filter-toggle,
            .header-sort-toggle {
                padding: 8px;
                font-size: 16px;
                min-width: 36px;
                justify-content: center;
            }
            
            .header-filter-toggle span,
            .header-sort-toggle span {
                display: none;
            }
            
            .header-filter-toggle::before {
                content: '📚';
            }
            
            .header-sort-toggle::before {
                content: '🔤';
            }
            
            .header-filter-toggle::after,
            .header-sort-toggle::after {
                display: none;
            }
            
            .header-dropdown-menu {
                right: auto;
                left: 0;
                max-height: 300px;
                overflow-y: auto;
            }
            
            .header-filter-dropdown .header-dropdown-menu,
            .header-sort-dropdown .header-dropdown-menu {
                position: fixed;
                top: auto;
                left: 10px;
                right: 10px;
                width: auto;
                min-width: auto;
            }
            
            .settings-menu-toggle {
                width: 36px;
                height: 36px;
                padding: 8px;
                font-size: 18px;
            }
            
            .actions-bar {
                padding: 10px;
                gap: 6px;
                flex-wrap: nowrap;
                overflow-x: auto;
            }
            
            .btn {
                padding: 10px;
                font-size: 18px;
                min-width: 40px;
                width: 40px;
                height: 40px;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .btn span {
                display: none;
            }
            
            .button-group {
                display: flex;
                gap: 6px;
                flex-wrap: nowrap;
            }
            
            .button-group .btn {
                flex: 0 0 auto;
            }
            
            .button-group:last-of-type {
                margin-left: 6px;
            }
            
            .select-info {
                flex-basis: 100%;
                text-align: center;
                margin-left: 0;
                margin-top: 8px;
                font-size: 13px;
                order: 10;
            }
            
            .file-list-header {
                grid-template-columns: 25px 25px 1fr 70px;
                padding: 10px;
                font-size: 13px;
            }
            
            .file-list-header > div:nth-child(4),
            .file-list-header > div:nth-child(5) {
                display: none;
            }
            
            .file-item {
                grid-template-columns: 30px 1fr 80px;
                padding: 10px;
                gap: 8px;
            }
            
            .file-item.indented {
                padding-left: 25px;
            }
            
            .file-item > div:nth-child(4) {
                grid-column: 2 / 4;
                margin-top: 8px;
            }
            
            .file-actions {
                flex-direction: column;
                gap: 5px;
                width: 100%;
            }
            
            .btn-small {
                width: 100%;
                text-align: center;
            }
            
            .search-bar {
                padding: 10px;
            }
            
            .search-bar-wrapper {
                flex-direction: column;
                gap: 8px;
            }
            
            .filter-dropdown {
                width: 100%;
            }
            
            .filter-dropdown-toggle {
                width: 100%;
                justify-content: center;
            }
            
            .filter-dropdown-menu {
                left: 0;
                right: auto;
                width: 100%;
            }
            
            .file-actions-dropdown {
                width: 100%;
            }
            
            .dropdown-toggle {
                width: 100%;
                justify-content: center;
            }
            
            .dropdown-menu {
                left: 0;
                right: auto;
                width: 100%;
            }
            
            .file-name {
                font-size: 14px;
            }
            
            .file-path {
                font-size: 11px;
            }
            
            .directory-header {
                padding: 10px;
                font-size: 13px;
                grid-template-columns: 30px 1fr;
                gap: 8px;
            }
            
            .directory-header-clickable {
                grid-template-columns: 12px 14px 1fr 60px;
                gap: 6px;
                font-size: 12px;
            }
            
            .directory-path {
                font-size: 12px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            .directory-file-count {
                font-size: 11px;
                text-align: right;
            }
            
            .directory-toggle {
                font-size: 10px;
                width: 12px;
            }
            
            .directory-icon {
                font-size: 14px;
            }
            
            .modal-content {
                max-width: 95%;
                margin: 10px;
            }
            
            .modal-header,
            .modal-body,
            .modal-footer {
                padding: 15px;
            }
            
            .modal-footer {
                flex-direction: column;
            }
            
            .modal-footer .btn {
                width: 100%;
            }
            
            .form-group input,
            .form-group textarea {
                font-size: 16px; /* Prevents zoom on iOS */
            }
            
            .pagination {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .pagination > div {
                margin-left: 0 !important;
                flex-basis: 100%;
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .header h1 {
                font-size: 20px;
            }
            
            .btn {
                font-size: 12px;
                padding: 6px 10px;
            }
            
            .file-list-header {
                grid-template-columns: 20px 25px 1fr 70px;
            }
            
            .file-item {
                grid-template-columns: 25px 1fr 70px;
                margin-left: 20px;
            }
            
            .directory-header {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container">
            <div class="header-content">
                <div class="header-left">
                    <svg width="48" height="48" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <!-- Brown border/frame -->
                        <rect x="5" y="5" width="90" height="90" rx="10" fill="#8B5A3C" stroke="#5C3A28" stroke-width="2"/>
                        <rect x="10" y="10" width="80" height="80" rx="8" fill="#A67C52"/>
                        
                        <!-- Teal shelf background -->
                        <rect x="15" y="15" width="70" height="70" rx="6" fill="#7CB8B8"/>
                        
                        <!-- Three comic books -->
                        <!-- Left book - yellow/green -->
                        <rect x="20" y="22" width="18" height="30" rx="2" fill="#D4D46E" stroke="#5C3A28" stroke-width="1.5"/>
                        <rect x="20" y="22" width="18" height="8" fill="#B8B85A"/>
                        <text x="29" y="38" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">C</text>
                        <text x="29" y="48" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">M</text>
                        
                        <!-- Middle book - orange/red -->
                        <rect x="41" y="22" width="18" height="30" rx="2" fill="#E67E5A" stroke="#5C3A28" stroke-width="1.5"/>
                        <rect x="41" y="22" width="18" height="8" fill="#CC6644"/>
                        <text x="50" y="38" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">O</text>
                        <text x="50" y="48" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">M</text>
                        
                        <!-- Right book - beige -->
                        <rect x="62" y="22" width="18" height="30" rx="2" fill="#E8D4C4" stroke="#5C3A28" stroke-width="1.5"/>
                        <rect x="62" y="22" width="18" height="8" fill="#D4BCA8"/>
                        <text x="71" y="38" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">C</text>
                        <text x="71" y="48" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">C</text>
                        
                        <!-- Label "COMIC LIBRARY" -->
                        <rect x="20" y="54" width="60" height="10" rx="2" fill="#F4C430"/>
                        <text x="50" y="61.5" font-family="Arial, sans-serif" font-size="6" font-weight="bold" fill="#5C3A28" text-anchor="middle">COMIC LIBRARY</text>
                        
                        <!-- Bottom shelf with books -->
                        <rect x="20" y="68" width="8" height="12" fill="#6A8AB8"/>
                        <rect x="30" y="68" width="6" height="12" fill="#E67E5A"/>
                        <rect x="38" y="68" width="8" height="12" fill="#7CB8B8"/>
                        <rect x="48" y="68" width="6" height="12" fill="#E8D4C4"/>
                        <rect x="58" y="68" width="6" height="12" fill="#E67E5A"/>
                        <rect x="66" y="68" width="8" height="12" fill="#7CB8B8"/>
                        <rect x="76" y="68" width="6" height="12" fill="#D4A574"/>
                    </svg>
                </div>
                <div class="header-right">
                    <div class="header-controls">
                        <div class="header-search">
                            <input type="text" id="headerSearchInput" placeholder="🔍 Search files..." oninput="debouncedFilterFiles()" />
                        </div>
                        <div class="header-filter-dropdown">
                            <button class="header-filter-toggle" onclick="toggleHeaderFilterDropdown(event)" id="headerFilterToggle">
                                <span id="headerFilterLabel">📚 All</span>
                            </button>
                            <div class="header-dropdown-menu" id="headerFilterMenu">
                                <button class="header-dropdown-item active" onclick="setHeaderFilter('all')" data-filter="all">
                                    📚 All Files
                                </button>
                                <button class="header-dropdown-item" onclick="setHeaderFilter('unmarked')" data-filter="unmarked">
                                    ⚠️ Unmarked
                                </button>
                                <button class="header-dropdown-item" onclick="setHeaderFilter('marked')" data-filter="marked">
                                    ✅ Marked
                                </button>
                                <button class="header-dropdown-item" onclick="setHeaderFilter('duplicates')" data-filter="duplicates">
                                    🔁 Duplicates
                                </button>
                            </div>
                        </div>
                        <div class="header-sort-dropdown">
                            <button class="header-sort-toggle" onclick="toggleHeaderSortDropdown(event)" id="headerSortToggle">
                                <span id="headerSortLabel">🔤 Name</span>
                            </button>
                            <div class="header-dropdown-menu" id="headerSortMenu">
                                <button class="header-dropdown-item active" onclick="setSort('name')" data-sort="name">
                                    🔤 Name
                                </button>
                                <button class="header-dropdown-item" onclick="setSort('date')" data-sort="date">
                                    📅 Date
                                </button>
                                <button class="header-dropdown-item" onclick="setSort('size')" data-sort="size">
                                    💾 Size
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="settings-menu-wrapper">
                        <button class="settings-menu-toggle" onclick="toggleSettingsMenu(event)" id="settingsMenuToggle">
                            ⋮
                        </button>
                        <div class="settings-dropdown-menu" id="settingsDropdownMenu">
                            <button class="settings-dropdown-item" onclick="openAboutModal(); closeSettingsMenu();">
                                ℹ️ About
                            </button>
                            <button class="settings-dropdown-item" onclick="openSettings(); closeSettingsMenu();">
                                ⚙️ Settings
                            </button>
                            <button class="settings-dropdown-item" onclick="openLogsModal(); closeSettingsMenu();">
                                📋 View Logs
                            </button>
                            <button class="settings-dropdown-item" onclick="toggleTheme(); closeSettingsMenu();">
                                🌓 Toggle Theme
                            </button>
                            <button class="settings-dropdown-item" onclick="refreshFiles(); closeSettingsMenu();">
                                🔄 Refresh
                            </button>
                            <button class="settings-dropdown-item" onclick="scanUnmarkedFiles(); closeSettingsMenu();">
                                🔍 Scan Unmarked
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div id="messageContainer"></div>
        
        <div class="controls-wrapper">
            <div class="actions-bar">
                <div class="button-group">
                    <button class="btn btn-success" onclick="processAllFilesAsync()">
                        🚀<span> Process All</span>
                    </button>
                    <button class="btn btn-success" onclick="processUnmarkedFiles()">
                        ⚠️<span> Process Unmarked</span>
                    </button>
                    <button class="btn btn-success" onclick="processSelectedFilesAsync()" id="processSelectedBtn" disabled>
                        ⚡<span> Process Selected</span>
                    </button>
                </div>
                <div class="button-group">
                    <button class="btn btn-rename" onclick="renameAllFiles()">
                        📝<span> Rename All</span>
                    </button>
                    <button class="btn btn-rename" onclick="renameUnmarkedFiles()">
                        📝<span> Rename Unmarked</span>
                    </button>
                    <button class="btn btn-rename" onclick="renameSelectedFiles()" id="renameSelectedBtn" disabled>
                        📝<span> Rename Selected</span>
                    </button>
                </div>
                <div class="button-group">
                    <button class="btn btn-normalize" onclick="normalizeAllFiles()">
                        🔧<span> Normalize All</span>
                    </button>
                    <button class="btn btn-normalize" onclick="normalizeUnmarkedFiles()">
                        🔧<span> Normalize Unmarked</span>
                    </button>
                    <button class="btn btn-normalize" onclick="normalizeSelectedFiles()" id="normalizeSelectedBtn" disabled>
                        🔧<span> Normalize Selected</span>
                    </button>
                </div>
                <div class="button-group">
                    <button class="btn btn-warning" onclick="batchUpdateTags()" id="batchUpdateBtn" disabled>
                        ✏️<span> Update Selected</span>
                    </button>
                </div>
                <span class="select-info" id="selectInfo">No files selected</span>
            </div>

        </div>
        
        <div class="content-wrapper">
            <div class="file-list" id="fileList">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading files...</p>
                </div>
            </div>
            
            <!-- Pagination Controls -->
            <div class="pagination" id="pagination" style="display: none;">
                <button class="btn btn-small" id="prevBtn" onclick="previousPage()" disabled>← Previous</button>
                <span class="page-info" id="pageInfo">Page 1 of 1</span>
                <button class="btn btn-small" id="nextBtn" onclick="nextPage()" disabled>Next →</button>
                <div style="display: flex; align-items: center; gap: 8px; margin-left: 15px;">
                    <label for="perPageSelect" style="color: var(--text-secondary); font-size: 14px;">Files per page:</label>
                    <select id="perPageSelect" onchange="changePerPage()" style="padding: 5px 10px; border-radius: 4px; border: 1px solid var(--border-primary); background: var(--bg-secondary); color: var(--text-primary); cursor: pointer;">
                        <option value="25">25</option>
                        <option value="50">50</option>
                        <option value="100" selected>100</option>
                        <option value="200">200</option>
                        <option value="500">500</option>
                        <option value="-1">All</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Tag Editor Modal -->
    <div class="modal" id="tagModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Edit Tags</h2>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="tagForm">
                    <div class="form-group">
                        <label for="title">Title</label>
                        <input type="text" id="title" name="title">
                    </div>
                    <div class="form-group">
                        <label for="series">Series</label>
                        <input type="text" id="series" name="series">
                    </div>
                    <div class="form-group">
                        <label for="issue">Issue</label>
                        <input type="text" id="issue" name="issue">
                    </div>
                    <div class="form-group">
                        <label for="volume">Volume</label>
                        <input type="text" id="volume" name="volume">
                    </div>
                    <div class="form-group">
                        <label for="publisher">Publisher</label>
                        <input type="text" id="publisher" name="publisher">
                    </div>
                    <div class="form-group">
                        <label for="year">Year</label>
                        <input type="text" id="year" name="year">
                    </div>
                    <div class="form-group">
                        <label for="month">Month</label>
                        <input type="text" id="month" name="month">
                    </div>
                    <div class="form-group">
                        <label for="writer">Writer</label>
                        <input type="text" id="writer" name="writer">
                    </div>
                    <div class="form-group">
                        <label for="summary">Summary</label>
                        <textarea id="summary" name="summary"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="notes">Notes</label>
                        <textarea id="notes" name="notes"></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTags()">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Batch Update Modal -->
    <div class="modal" id="batchModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Batch Update Tags</h2>
                <button class="close-btn" onclick="closeBatchModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: #7f8c8d;">
                    Only fill in the fields you want to update for all selected files.
                    Empty fields will be ignored.
                </p>
                <form id="batchForm">
                    <div class="form-group">
                        <label for="batch_series">Series</label>
                        <input type="text" id="batch_series" name="series">
                    </div>
                    <div class="form-group">
                        <label for="batch_publisher">Publisher</label>
                        <input type="text" id="batch_publisher" name="publisher">
                    </div>
                    <div class="form-group">
                        <label for="batch_year">Year</label>
                        <input type="text" id="batch_year" name="year">
                    </div>
                    <div class="form-group">
                        <label for="batch_writer">Writer</label>
                        <input type="text" id="batch_writer" name="writer">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeBatchModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveBatchTags()">Update Selected Files</button>
            </div>
        </div>
    </div>
    
    <!-- About Modal -->
    <div class="modal" id="aboutModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2>About Comic Maintainer</h2>
                <button class="close-btn" onclick="closeAboutModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div style="text-align: center; margin-bottom: 20px;">
                    <svg width="80" height="80" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <!-- Brown border/frame -->
                        <rect x="5" y="5" width="90" height="90" rx="10" fill="#8B5A3C" stroke="#5C3A28" stroke-width="2"/>
                        <rect x="10" y="10" width="80" height="80" rx="8" fill="#A67C52"/>
                        
                        <!-- Teal shelf background -->
                        <rect x="15" y="15" width="70" height="70" rx="6" fill="#7CB8B8"/>
                        
                        <!-- Three comic books -->
                        <!-- Left book - yellow/green -->
                        <rect x="20" y="22" width="18" height="30" rx="2" fill="#D4D46E" stroke="#5C3A28" stroke-width="1.5"/>
                        <rect x="20" y="22" width="18" height="8" fill="#B8B85A"/>
                        <text x="29" y="38" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">C</text>
                        <text x="29" y="48" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">M</text>
                        
                        <!-- Middle book - orange/red -->
                        <rect x="41" y="22" width="18" height="30" rx="2" fill="#E67E5A" stroke="#5C3A28" stroke-width="1.5"/>
                        <rect x="41" y="22" width="18" height="8" fill="#CC6644"/>
                        <text x="50" y="38" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">O</text>
                        <text x="50" y="48" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">M</text>
                        
                        <!-- Right book - beige -->
                        <rect x="62" y="22" width="18" height="30" rx="2" fill="#E8D4C4" stroke="#5C3A28" stroke-width="1.5"/>
                        <rect x="62" y="22" width="18" height="8" fill="#D4BCA8"/>
                        <text x="71" y="38" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">C</text>
                        <text x="71" y="48" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#5C3A28" text-anchor="middle">C</text>
                        
                        <!-- Label "COMIC LIBRARY" -->
                        <rect x="20" y="54" width="60" height="10" rx="2" fill="#F4C430"/>
                        <text x="50" y="61.5" font-family="Arial, sans-serif" font-size="6" font-weight="bold" fill="#5C3A28" text-anchor="middle">COMIC LIBRARY</text>
                        
                        <!-- Bottom shelf with books -->
                        <rect x="20" y="68" width="8" height="12" fill="#6A8AB8"/>
                        <rect x="30" y="68" width="6" height="12" fill="#E67E5A"/>
                        <rect x="38" y="68" width="8" height="12" fill="#7CB8B8"/>
                        <rect x="48" y="68" width="6" height="12" fill="#E8D4C4"/>
                        <rect x="58" y="68" width="6" height="12" fill="#E67E5A"/>
                        <rect x="66" y="68" width="8" height="12" fill="#7CB8B8"/>
                        <rect x="76" y="68" width="6" height="12" fill="#D4A574"/>
                    </svg>
                </div>
                
                <h3 style="margin-bottom: 10px; color: var(--text-secondary); text-align: center;">Comic Maintainer</h3>
                <p style="text-align: center; color: var(--text-muted); margin-bottom: 20px;">
                    Version: <strong id="aboutVersion">Loading...</strong>
                </p>
                
                <div style="padding: 15px; background: var(--bg-hover); border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin-bottom: 10px; color: var(--text-secondary);">Description</h4>
                    <p style="color: var(--text-primary); line-height: 1.6;">
                        Comic Maintainer is a service that automatically watches a directory for new or changed comic archive files (.cbz/.cbr), 
                        tags them using ComicTagger, and manages duplicates. It provides a web interface for managing and processing comic files 
                        in your watched directory.
                    </p>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="padding: 15px; background: var(--bg-hover); border-radius: 8px;">
                        <h4 style="margin-bottom: 8px; color: var(--text-secondary);">Created</h4>
                        <p style="color: var(--text-primary);">2024</p>
                    </div>
                    <div style="padding: 15px; background: var(--bg-hover); border-radius: 8px;">
                        <h4 style="margin-bottom: 8px; color: var(--text-secondary);">License</h4>
                        <p style="color: var(--text-primary);">MIT</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeAboutModal()">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Progress Modal -->
    <div class="modal" id="progressModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="progressTitle">Processing Files...</h2>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill" id="progressBarFill"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 8px;">
                        <span id="progressText" style="color: var(--text-secondary); font-size: 14px;">0 / 0 files</span>
                        <span id="progressPercent" style="color: var(--text-secondary); font-size: 14px;">0%</span>
                    </div>
                </div>
                <div id="progressDetails" style="max-height: 200px; overflow-y: auto; padding: 10px; background: var(--bg-hover); border-radius: 5px; font-size: 13px; color: var(--text-muted);"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="progressCloseBtn" onclick="closeProgressModal()" style="display: none;">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="close-btn" onclick="closeSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <h3 style="margin-bottom: 10px; color: var(--text-secondary);">Appearance</h3>
                <div class="form-group">
                    <label for="themeSelect">Theme</label>
                    <select id="themeSelect" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid var(--border-input); background: var(--bg-primary); color: var(--text-primary);" onchange="updateThemeFromSettings()">
                        <option value="light">Light Mode</option>
                        <option value="dark">Dark Mode</option>
                    </select>
                </div>
                
                <h3 style="margin-bottom: 10px; margin-top: 25px; color: var(--text-secondary);">Watcher</h3>
                <div class="form-group">
                    <label for="watcherToggleCheckbox" style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="watcherToggleCheckbox" onchange="updateWatcherFromSettings()" style="margin-right: 10px; width: 20px; height: 20px; cursor: pointer;">
                        <span>Enable file watcher (automatically process new/modified files)</span>
                    </label>
                    <small style="display: block; margin-top: 5px; margin-left: 30px; color: var(--text-muted);">
                        When enabled, the watcher monitors the directory for changes and automatically processes files.
                    </small>
                </div>
                
                <h3 style="margin-bottom: 10px; margin-top: 25px; color: var(--text-secondary);">Log Rotation</h3>
                <div class="form-group">
                    <label for="logMaxSize">Maximum Log File Size (MB)</label>
                    <input type="number" id="logMaxSize" min="1" max="100" step="1" placeholder="5" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid var(--border-input); background: var(--bg-primary); color: var(--text-primary);">
                    <small style="display: block; margin-top: 5px; color: var(--text-muted);">
                        When the log file reaches this size, it will be rotated. Up to 3 backup files will be kept. Changes take effect on restart.
                    </small>
                    <small style="display: block; margin-top: 5px; color: var(--text-muted);">
                        <strong>Note:</strong> Can also be configured via the <code>LOG_MAX_BYTES</code> environment variable (in bytes).
                    </small>
                </div>
                
                <h3 style="margin-bottom: 10px; margin-top: 25px; color: var(--text-secondary);">Filename Format</h3>
                <p style="margin-bottom: 15px; color: var(--text-muted); font-size: 14px;">
                    Configure how files are renamed when processed. Use placeholders like <code>{series}</code>, <code>{issue}</code>, etc.
                </p>
                <div class="form-group">
                    <label for="filenameFormat">Filename Template</label>
                    <input type="text" id="filenameFormat" placeholder="{series} - Chapter {issue}.cbz">
                    <small style="display: block; margin-top: 5px; color: var(--text-muted);">
                        Available placeholders:
                    </small>
                    <ul style="margin: 10px 0 10px 20px; color: var(--text-muted); font-size: 13px; line-height: 1.6;">
                        <li><code>{series}</code> - Series name</li>
                        <li><code>{issue}</code> - Issue number (padded to 4 digits, e.g., 0001, or 0071.4 for decimals)</li>
                        <li><code>{issue_no_pad}</code> - Issue number (no padding, e.g., 1, or 71.4 for decimals)</li>
                        <li><code>{title}</code> - Issue title</li>
                        <li><code>{volume}</code> - Volume number</li>
                        <li><code>{year}</code> - Publication year</li>
                        <li><code>{publisher}</code> - Publisher name</li>
                    </ul>
                    <small style="display: block; margin-top: 10px; color: var(--text-muted);">
                        <strong>Example:</strong> <code>{series} v{volume} #{issue_no_pad} ({year}).cbz</code>
                    </small>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: var(--bg-hover); border-radius: 5px;">
                    <small style="color: var(--text-muted);">
                        <strong>Current format:</strong> <span id="currentFormat" style="font-family: monospace;"></span>
                    </small>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeSettings()">Cancel</button>
                <button class="btn" onclick="resetFilenameFormat()" style="background: #e67e22; color: white;">Reset to Default</button>
                <button class="btn btn-primary" onclick="saveFilenameFormat()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="logsModal">
        <div class="modal-content" style="max-width: 900px; height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Application Logs</h2>
                <button class="close-btn" onclick="closeLogsModal()">&times;</button>
            </div>
            <div class="modal-body" style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                <div style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center;">
                    <label for="logLines" style="color: var(--text-secondary); font-weight: 500;">Lines to display:</label>
                    <select id="logLines" onchange="loadLogs()" style="padding: 5px 10px; border-radius: 5px; border: 1px solid var(--border-input); background: var(--bg-primary); color: var(--text-primary);">
                        <option value="100">Last 100 lines</option>
                        <option value="500" selected>Last 500 lines</option>
                        <option value="1000">Last 1000 lines</option>
                        <option value="0">All lines</option>
                    </select>
                    <button class="btn" onclick="loadLogs()" style="margin-left: auto;">🔄 Refresh</button>
                </div>
                <div id="logsLoadingIndicator" style="display: none; padding: 20px; text-align: center; color: var(--text-muted);">
                    Loading logs...
                </div>
                <pre id="logsContent" style="flex: 1; overflow: auto; background: var(--bg-primary); padding: 15px; border-radius: 5px; border: 1px solid var(--border-secondary); font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; margin: 0;"></pre>
                <div style="margin-top: 10px; padding: 10px; background: var(--bg-hover); border-radius: 5px; font-size: 13px; color: var(--text-muted);">
                    <span id="logStats"></span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeLogsModal()">Close</button>
            </div>
        </div>
    </div>
    
    <script>
        let files = [];
        let selectedFiles = new Set();
        let currentEditFile = null;
        let collapsedDirectories = new Set();
        let searchQuery = '';
        let allFoldersExpanded = true;
        let currentPage = 1;
        let totalPages = 1;
        let totalFiles = 0;
        let unmarkedCount = 0;
        let perPage = parseInt(localStorage.getItem('perPage')) || 100;
        let filterMode = 'all'; // 'all', 'marked', 'unmarked', 'duplicates'
        let searchDebounceTimer = null;
        
        // Debounce function for search input
        function debouncedFilterFiles() {
            // Clear existing timer
            if (searchDebounceTimer) {
                clearTimeout(searchDebounceTimer);
            }
            
            // Set new timer to trigger after 300ms of inactivity
            searchDebounceTimer = setTimeout(() => {
                filterFiles();
            }, 300);
        }
        
        // Theme management
        function initTheme() {
            // Check if user has a saved preference
            const savedTheme = localStorage.getItem('theme');
            
            if (savedTheme) {
                // Use saved preference
                setTheme(savedTheme);
            } else {
                // Use system preference
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                setTheme(prefersDark ? 'dark' : 'light');
            }
            
            // Listen for system theme changes
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                // Only auto-switch if user hasn't set a preference
                if (!localStorage.getItem('theme')) {
                    setTheme(e.matches ? 'dark' : 'light');
                }
            });
        }
        
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
            localStorage.setItem('theme', newTheme);
        }
        
        // Update theme from settings modal
        function updateThemeFromSettings() {
            const selectedTheme = document.getElementById('themeSelect').value;
            setTheme(selectedTheme);
            localStorage.setItem('theme', selectedTheme);
        }
        
        // Update watcher from settings modal
        async function updateWatcherFromSettings() {
            const enabled = document.getElementById('watcherToggleCheckbox').checked;
            
            try {
                const response = await fetch('/api/settings/watcher-enabled', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled: enabled })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const statusText = result.enabled ? 'enabled' : 'disabled';
                    showMessage(`Watcher ${statusText} successfully!`, 'success');
                } else {
                    showMessage(result.error || 'Failed to update watcher', 'error');
                    // Revert checkbox on error
                    document.getElementById('watcherToggleCheckbox').checked = !enabled;
                }
            } catch (error) {
                showMessage('Failed to update watcher: ' + error.message, 'error');
                // Revert checkbox on error
                document.getElementById('watcherToggleCheckbox').checked = !enabled;
            }
        }
        
        // Fetch and display version
        async function loadVersion() {
            try {
                const response = await fetch('/api/version');
                const data = await response.json();
                const versionElement = document.getElementById('appVersion');
                if (versionElement && data.version) {
                    versionElement.textContent = `v${data.version}`;
                }
            } catch (error) {
                console.error('Error loading version:', error);
            }
        }
        
        // Load files on page load
        document.addEventListener('DOMContentLoaded', function() {
            initTheme();
            loadVersion();
            
            // Set the per-page selector to the saved value
            const perPageSelect = document.getElementById('perPageSelect');
            if (perPageSelect) {
                perPageSelect.value = perPage;
            }
            
            loadFiles();
        });
        
        async function loadFiles(page = 1, refresh = false) {
            try {
                let url = `/api/files?page=${page}&per_page=${perPage}`;
                if (refresh) {
                    url += '&refresh=true';
                }
                if (searchQuery) {
                    url += `&search=${encodeURIComponent(searchQuery)}`;
                }
                if (filterMode !== 'all') {
                    url += `&filter=${encodeURIComponent(filterMode)}`;
                }
                if (sortMode !== 'name') {
                    url += `&sort=${encodeURIComponent(sortMode)}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                files = data.files;
                currentPage = data.page;
                totalPages = data.total_pages;
                totalFiles = data.total_files;
                unmarkedCount = data.unmarked_count || 0;
                
                renderFileList();
                updatePagination();
                updateButtonVisibility();
            } catch (error) {
                showMessage('Failed to load files: ' + error.message, 'error');
            }
        }
        
        function updatePagination() {
            const paginationDiv = document.getElementById('pagination');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            if (totalPages > 1 || totalFiles > 0) {
                paginationDiv.style.display = 'flex';
                let pageText = `Page ${currentPage} of ${totalPages} (${totalFiles} file${totalFiles !== 1 ? 's' : ''}`;
                if (searchQuery || filterMode !== 'all') {
                    pageText += ' matching';
                }
                pageText += ')';
                pageInfo.textContent = pageText;
                prevBtn.disabled = currentPage <= 1;
                nextBtn.disabled = currentPage >= totalPages;
            } else {
                paginationDiv.style.display = 'none';
            }
        }
        
        function updateButtonVisibility() {
            // Get all unmarked-related buttons
            const processUnmarkedBtn = document.querySelector('button[onclick="processUnmarkedFiles()"]');
            const renameUnmarkedBtn = document.querySelector('button[onclick="renameUnmarkedFiles()"]');
            const normalizeUnmarkedBtn = document.querySelector('button[onclick="normalizeUnmarkedFiles()"]');
            const filterUnmarkedBtn = document.getElementById('filterUnmarked');
            
            // Show or hide buttons based on whether there are unmarked files
            const hasUnmarkedFiles = unmarkedCount > 0;
            const displayStyle = hasUnmarkedFiles ? '' : 'none';
            
            if (processUnmarkedBtn) processUnmarkedBtn.style.display = displayStyle;
            if (renameUnmarkedBtn) renameUnmarkedBtn.style.display = displayStyle;
            if (normalizeUnmarkedBtn) normalizeUnmarkedBtn.style.display = displayStyle;
            if (filterUnmarkedBtn) filterUnmarkedBtn.style.display = displayStyle;
        }
        
        function changePerPage() {
            const perPageSelect = document.getElementById('perPageSelect');
            perPage = parseInt(perPageSelect.value);
            
            // Save to localStorage
            localStorage.setItem('perPage', perPage);
            
            // Reload files from page 1 with new per-page value
            loadFiles(1);
        }
        
        function nextPage() {
            if (currentPage < totalPages) {
                loadFiles(currentPage + 1);
            }
        }
        
        function previousPage() {
            if (currentPage > 1) {
                loadFiles(currentPage - 1);
            }
        }
        
        function filterFiles() {
            searchQuery = document.getElementById('headerSearchInput').value;
            // Reload from page 1 with new search query
            loadFiles(1);
        }
        
        let sortMode = 'name'; // 'name', 'date', 'size'
        
        function setHeaderFilter(mode) {
            filterMode = mode;
            
            // Update dropdown label and active state
            const filterLabels = {
                'all': '📚 All',
                'unmarked': '⚠️ Unmarked',
                'marked': '✅ Marked',
                'duplicates': '🔁 Duplicates'
            };
            
            document.getElementById('headerFilterLabel').textContent = filterLabels[mode];
            
            // Update active class on dropdown items
            document.querySelectorAll('#headerFilterMenu .header-dropdown-item').forEach(item => {
                if (item.dataset.filter === mode) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            // Close the dropdown
            document.getElementById('headerFilterMenu').classList.remove('show');
            
            // Reload from page 1 with new filter
            loadFiles(1);
        }
        
        function setSort(mode) {
            sortMode = mode;
            
            // Update dropdown label and active state
            const sortLabels = {
                'name': '🔤 Name',
                'date': '📅 Date',
                'size': '💾 Size'
            };
            
            document.getElementById('headerSortLabel').textContent = sortLabels[mode];
            
            // Update active class on dropdown items
            document.querySelectorAll('#headerSortMenu .header-dropdown-item').forEach(item => {
                if (item.dataset.sort === mode) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            // Close the dropdown
            document.getElementById('headerSortMenu').classList.remove('show');
            
            // Reload from page 1 with new sort order
            loadFiles(1);
        }
        
        function toggleHeaderFilterDropdown(event) {
            event.stopPropagation();
            const menu = document.getElementById('headerFilterMenu');
            const sortMenu = document.getElementById('headerSortMenu');
            sortMenu.classList.remove('show');
            menu.classList.toggle('show');
        }
        
        function toggleHeaderSortDropdown(event) {
            event.stopPropagation();
            const menu = document.getElementById('headerSortMenu');
            const filterMenu = document.getElementById('headerFilterMenu');
            filterMenu.classList.remove('show');
            menu.classList.toggle('show');
        }
        
        function setFilter(mode) {
            // Redirect to header filter function
            setHeaderFilter(mode);
        }
        
        function toggleFilterDropdown(event) {
            // Redirect to header filter toggle
            toggleHeaderFilterDropdown(event);
        }
        
        function toggleSettingsMenu(event) {
            event.stopPropagation();
            const menu = document.getElementById('settingsDropdownMenu');
            menu.classList.toggle('show');
        }
        
        function closeSettingsMenu() {
            const menu = document.getElementById('settingsDropdownMenu');
            menu.classList.remove('show');
        }
        
        async function scanUnmarkedFiles() {
            try {
                showMessage('Scanning for unmarked files...', 'info');
                const response = await fetch('/api/scan-unmarked');
                const data = await response.json();
                
                showMessage(`Found ${data.unmarked_count} unmarked file(s) and ${data.marked_count} marked file(s) out of ${data.total_count} total files.`, 'success');
            } catch (error) {
                showMessage('Failed to scan files: ' + error.message, 'error');
            }
        }
        
        function renderFileList() {
            const fileList = document.getElementById('fileList');
            
            if (files.length === 0) {
                // Check if we have search/filter active to show appropriate message
                if (searchQuery || filterMode !== 'all') {
                    fileList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">🔍</div>
                            <h2>No matching files found</h2>
                            <p>Try a different search term or filter</p>
                        </div>
                    `;
                } else {
                    fileList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">📁</div>
                            <h2>No comic files found</h2>
                            <p>Add some .cbz or .cbr files to your watched directory</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Group files by directory (filtering is now done on backend)
            const filesByDirectory = {};
            files.forEach(file => {
                const dirPath = file.relative_path.includes('/') || file.relative_path.includes('\\') 
                    ? file.relative_path.substring(0, file.relative_path.lastIndexOf(file.relative_path.includes('/') ? '/' : '\\'))
                    : '';
                if (!filesByDirectory[dirPath]) {
                    filesByDirectory[dirPath] = [];
                }
                filesByDirectory[dirPath].push(file);
            });
            
            // Sort directories
            const sortedDirs = Object.keys(filesByDirectory).sort();
            
            let html = `
                <div class="file-list-header">
                    <input type="checkbox" id="selectAll" onchange="toggleSelectAll(this.checked)">
                    <button class="toggle-all-btn" onclick="toggleAllFolders()" id="toggleAllBtn" title="Expand/Collapse All">
                        ${allFoldersExpanded ? '▼' : '▶'}
                    </button>
                    <div>File</div>
                    <div>Size</div>
                    <div>Actions</div>
                </div>
            `;
            
            // Render files grouped by directory
            sortedDirs.forEach(dir => {
                const isCollapsed = collapsedDirectories.has(dir);
                const fileCount = filesByDirectory[dir].length;
                
                if (dir) {
                    const allSelected = filesByDirectory[dir].every(file => selectedFiles.has(file.relative_path));
                    const someSelected = filesByDirectory[dir].some(file => selectedFiles.has(file.relative_path));
                    html += `
                        <div class="directory-header">
                            <input type="checkbox" 
                                   class="directory-checkbox"
                                   ${allSelected ? 'checked' : ''} 
                                   ${someSelected && !allSelected ? 'style="opacity: 0.5"' : ''}
                                   onchange="toggleDirectorySelection('${escapeJs(dir)}', this.checked)"
                                   onclick="event.stopPropagation()">
                            <div class="directory-header-clickable" onclick="toggleDirectory('${escapeJs(dir)}')">
                                <span class="directory-toggle ${isCollapsed ? 'collapsed' : ''}">▼</span>
                                <span class="directory-icon">📁</span>
                                <span class="directory-path">${escapeHtml(dir)}</span>
                                <span class="directory-file-count">${fileCount} file${fileCount !== 1 ? 's' : ''}</span>
                            </div>
                        </div>
                    `;
                }
                
                html += `<div class="directory-content ${isCollapsed ? 'collapsed' : ''}" data-dir="${escapeHtml(dir)}">`;
                
                filesByDirectory[dir].forEach(file => {
                    const isSelected = selectedFiles.has(file.relative_path);
                    const fileSize = formatFileSize(file.size);
                    const processedBadge = file.processed ? '✅' : '⚠️';
                    const processedTitle = file.processed ? 'Processed' : 'Not processed yet';
                    const duplicateBadge = file.duplicate ? '🔁' : '';
                    const duplicateTitle = file.duplicate ? 'Duplicate' : '';
                    html += `
                        <div class="file-item ${dir ? 'indented' : ''}">
                            <input type="checkbox" 
                                   ${isSelected ? 'checked' : ''} 
                                   onchange="toggleFileSelection('${escapeJs(file.relative_path)}', this.checked)">
                            <div>
                                <div class="file-name">
                                    <span title="${processedTitle}">${processedBadge}</span>${duplicateBadge ? ` <span title="${duplicateTitle}">${duplicateBadge}</span>` : ''} ${escapeHtml(file.name)}
                                </div>
                                ${!dir ? `<div class="file-path">${escapeHtml(file.relative_path)}</div>` : ''}
                            </div>
                            <div>${fileSize}</div>
                            <div class="file-actions">
                                <div class="file-actions-dropdown">
                                    <button class="dropdown-toggle" onclick="toggleDropdown(event, '${escapeJs(file.relative_path)}')">
                                        Actions
                                    </button>
                                    <div class="dropdown-menu" id="dropdown-${escapeJs(file.relative_path).replace(/[^a-zA-Z0-9]/g, '_')}">
                                        <button class="dropdown-item" onclick="viewTags('${escapeJs(file.relative_path)}'); closeAllDropdowns();">
                                            👁️ View/Edit
                                        </button>
                                        <div class="dropdown-divider"></div>
                                        <button class="dropdown-item" onclick="processSingleFile('${escapeJs(file.relative_path)}'); closeAllDropdowns();">
                                            🚀 Process
                                        </button>
                                        <button class="dropdown-item" onclick="renameSingleFile('${escapeJs(file.relative_path)}'); closeAllDropdowns();">
                                            📝 Rename
                                        </button>
                                        <button class="dropdown-item" onclick="normalizeSingleFile('${escapeJs(file.relative_path)}'); closeAllDropdowns();">
                                            ✨ Normalize
                                        </button>
                                        <div class="dropdown-divider"></div>
                                        <button class="dropdown-item" onclick="deleteSingleFile('${escapeJs(file.relative_path)}'); closeAllDropdowns();">
                                            🗑️ Delete
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            });
            
            fileList.innerHTML = html;
            
            // Clean up selectedFiles to remove files that no longer exist
            const currentFilePaths = new Set(files.map(f => f.relative_path));
            for (const filepath of selectedFiles) {
                if (!currentFilePaths.has(filepath)) {
                    selectedFiles.delete(filepath);
                }
            }
            
            updateSelectInfo();
            updateSelectAllCheckbox();
            updateToggleAllButton();
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeJs(text) {
            // Escape single quotes, double quotes, backslashes, and other special characters for JavaScript strings
            return text.replace(/\\/g, '\\\\')
                       .replace(/'/g, "\\'")
                       .replace(/"/g, '\\"')
                       .replace(/\n/g, '\\n')
                       .replace(/\r/g, '\\r')
                       .replace(/\t/g, '\\t');
        }
        
        function toggleSelectAll(checked) {
            selectedFiles.clear();
            if (checked) {
                files.forEach(file => selectedFiles.add(file.relative_path));
            }
            renderFileList();
        }
        
        function toggleFileSelection(filepath, checked) {
            if (checked) {
                selectedFiles.add(filepath);
            } else {
                selectedFiles.delete(filepath);
            }
            updateSelectInfo();
            updateSelectAllCheckbox();
        }
        
        function updateSelectInfo() {
            const count = selectedFiles.size;
            const info = document.getElementById('selectInfo');
            const batchBtn = document.getElementById('batchUpdateBtn');
            const processSelectedBtn = document.getElementById('processSelectedBtn');
            const renameSelectedBtn = document.getElementById('renameSelectedBtn');
            const normalizeSelectedBtn = document.getElementById('normalizeSelectedBtn');
            
            if (count === 0) {
                info.textContent = 'No files selected';
                batchBtn.disabled = true;
                processSelectedBtn.disabled = true;
                renameSelectedBtn.disabled = true;
                normalizeSelectedBtn.disabled = true;
            } else {
                info.textContent = `${count} file${count > 1 ? 's' : ''} selected`;
                batchBtn.disabled = false;
                processSelectedBtn.disabled = false;
                renameSelectedBtn.disabled = false;
                normalizeSelectedBtn.disabled = false;
            }
        }
        
        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('selectAll');
            if (!selectAllCheckbox) return;
            
            if (files.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else {
                const allSelected = files.every(file => selectedFiles.has(file.relative_path));
                const someSelected = files.some(file => selectedFiles.has(file.relative_path));
                
                selectAllCheckbox.checked = allSelected;
                selectAllCheckbox.indeterminate = someSelected && !allSelected;
            }
        }
        
        function toggleDirectory(dir) {
            if (collapsedDirectories.has(dir)) {
                collapsedDirectories.delete(dir);
            } else {
                collapsedDirectories.add(dir);
            }
            updateToggleAllButton();
            renderFileList();
        }
        
        function toggleAllFolders() {
            if (allFoldersExpanded) {
                collapseAllFolders();
            } else {
                expandAllFolders();
            }
        }
        
        function expandAllFolders() {
            collapsedDirectories.clear();
            allFoldersExpanded = true;
            updateToggleAllButton();
            renderFileList();
        }
        
        function collapseAllFolders() {
            // Get all directories from files
            const allDirs = new Set();
            files.forEach(file => {
                const dirPath = file.relative_path.includes('/') || file.relative_path.includes('\\') 
                    ? file.relative_path.substring(0, file.relative_path.lastIndexOf(file.relative_path.includes('/') ? '/' : '\\'))
                    : '';
                if (dirPath) {
                    allDirs.add(dirPath);
                }
            });
            
            // Collapse all directories
            collapsedDirectories = new Set(allDirs);
            allFoldersExpanded = false;
            updateToggleAllButton();
            renderFileList();
        }
        
        function updateToggleAllButton() {
            // Count total directories
            const allDirs = new Set();
            files.forEach(file => {
                const dirPath = file.relative_path.includes('/') || file.relative_path.includes('\\') 
                    ? file.relative_path.substring(0, file.relative_path.lastIndexOf(file.relative_path.includes('/') ? '/' : '\\'))
                    : '';
                if (dirPath) {
                    allDirs.add(dirPath);
                }
            });
            
            // Update state based on collapsed directories
            if (collapsedDirectories.size === allDirs.size && allDirs.size > 0) {
                allFoldersExpanded = false;
            } else {
                allFoldersExpanded = true;
            }
        }
        
        function toggleDirectorySelection(dir, checked) {
            // Find all files in this directory
            const dirFiles = files.filter(file => {
                const fileDirPath = file.relative_path.includes('/') || file.relative_path.includes('\\') 
                    ? file.relative_path.substring(0, file.relative_path.lastIndexOf(file.relative_path.includes('/') ? '/' : '\\'))
                    : '';
                return fileDirPath === dir;
            });
            
            // Update selection
            dirFiles.forEach(file => {
                if (checked) {
                    selectedFiles.add(file.relative_path);
                } else {
                    selectedFiles.delete(file.relative_path);
                }
            });
            
            renderFileList();
        }
        
        async function viewTags(filepath) {
            try {
                const response = await fetch(`/api/file/${encodeURIComponent(filepath)}/tags`);
                const tags = await response.json();
                
                if (tags.error) {
                    showMessage(tags.error, 'error');
                    return;
                }
                
                currentEditFile = filepath;
                
                // Populate form
                Object.keys(tags).forEach(key => {
                    const input = document.getElementById(key);
                    if (input) {
                        input.value = tags[key] || '';
                    }
                });
                
                document.getElementById('modalTitle').textContent = `Edit Tags - ${filepath}`;
                document.getElementById('tagModal').classList.add('active');
            } catch (error) {
                showMessage('Failed to load tags: ' + error.message, 'error');
            }
        }
        
        function closeModal() {
            document.getElementById('tagModal').classList.remove('active');
            currentEditFile = null;
        }
        
        async function saveTags() {
            if (!currentEditFile) return;
            
            const form = document.getElementById('tagForm');
            const formData = new FormData(form);
            const tags = {};
            
            for (let [key, value] of formData.entries()) {
                tags[key] = value;
            }
            
            try {
                const response = await fetch(`/api/file/${encodeURIComponent(currentEditFile)}/tags`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(tags)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('Tags updated successfully!', 'success');
                    closeModal();
                } else {
                    showMessage(result.error || 'Failed to update tags', 'error');
                }
            } catch (error) {
                showMessage('Failed to save tags: ' + error.message, 'error');
            }
        }
        
        function batchUpdateTags() {
            if (selectedFiles.size === 0) return;
            document.getElementById('batchModal').classList.add('active');
        }
        
        function closeBatchModal() {
            document.getElementById('batchModal').classList.remove('active');
            document.getElementById('batchForm').reset();
        }
        
        async function saveBatchTags() {
            const form = document.getElementById('batchForm');
            const formData = new FormData(form);
            const tags = {};
            
            // Only include non-empty fields
            for (let [key, value] of formData.entries()) {
                if (value.trim()) {
                    tags[key] = value;
                }
            }
            
            if (Object.keys(tags).length === 0) {
                showMessage('Please enter at least one tag to update', 'error');
                return;
            }
            
            closeBatchModal();
            showProgressModal('Updating Tags...');
            
            const files = Array.from(selectedFiles);
            let successCount = 0;
            let errorCount = 0;
            
            try {
                const response = await fetch('/api/files/tags?stream=true', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: files,
                        tags: tags
                    })
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                completeProgress();
                                showMessage(`Updated ${successCount} of ${files.length} files successfully!`, 'success');
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to batch update: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function processAllFiles() {
            if (!confirm('This will process all files in the watched directory. Continue?')) {
                return;
            }
            
            showProgressModal('Processing All Files...');
            
            let successCount = 0;
            let errorCount = 0;
            let totalFiles = 0;
            
            try {
                const response = await fetch('/api/process-all?stream=true', {
                    method: 'POST'
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                totalFiles = data.results.length;
                                completeProgress();
                                showMessage(`Processed ${successCount} of ${totalFiles} files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to process files: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function processAllFilesAsync() {
            if (!confirm('This will process all files in the watched directory asynchronously. Continue?')) {
                return;
            }
            
            showProgressModal('Starting async processing...');
            
            try {
                // Start the job
                const response = await fetch('/api/jobs/process-all', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to start processing job');
                }
                
                const data = await response.json();
                const jobId = data.job_id;
                const totalItems = data.total_items;
                
                showMessage(`Started processing ${totalItems} files in background`, 'info');
                
                // Poll for status
                await pollJobStatus(jobId, 'Processing Files...');
                
            } catch (error) {
                showMessage('Failed to start processing: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function processSelectedFilesAsync() {
            if (selectedFiles.size === 0) {
                showMessage('Please select at least one file to process', 'error');
                return;
            }
            
            if (!confirm(`This will process ${selectedFiles.size} selected file${selectedFiles.size > 1 ? 's' : ''} asynchronously. Continue?`)) {
                return;
            }
            
            showProgressModal('Starting async processing...');
            
            const files = Array.from(selectedFiles);
            
            try {
                // Start the job
                const response = await fetch('/api/jobs/process-selected', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: files
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to start processing job');
                }
                
                const data = await response.json();
                const jobId = data.job_id;
                const totalItems = data.total_items;
                
                showMessage(`Started processing ${totalItems} files in background`, 'info');
                
                // Poll for status
                await pollJobStatus(jobId, 'Processing Selected Files...');
                
            } catch (error) {
                showMessage('Failed to start processing: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function pollJobStatus(jobId, title) {
            const pollInterval = 500; // Poll every 500ms
            let lastProcessed = 0;
            
            try {
                while (true) {
                    const response = await fetch(`/api/jobs/${jobId}`);
                    
                    if (!response.ok) {
                        throw new Error('Failed to get job status');
                    }
                    
                    const status = await response.json();
                    
                    // Update progress
                    const processed = status.processed_items;
                    const total = status.total_items;
                    
                    // Count successes and errors from results
                    let successCount = 0;
                    let errorCount = 0;
                    
                    for (const result of status.results) {
                        if (result.success) {
                            successCount++;
                        } else {
                            errorCount++;
                        }
                    }
                    
                    updateProgress(processed, total, successCount, errorCount);
                    
                    // Add details for newly processed items
                    if (processed > lastProcessed) {
                        for (let i = lastProcessed; i < processed; i++) {
                            const result = status.results[i];
                            addProgressDetail(result.item, result.success, result.error);
                        }
                        lastProcessed = processed;
                    }
                    
                    // Check if completed
                    if (status.status === 'completed') {
                        completeProgress();
                        showMessage(`Processed ${successCount} of ${total} files successfully!`, 'success');
                        // Refresh file list (force refresh to clear cache)
                        await loadFiles(1, true);
                        break;
                    } else if (status.status === 'failed') {
                        closeProgressModal();
                        showMessage(`Job failed: ${status.error}`, 'error');
                        break;
                    } else if (status.status === 'cancelled') {
                        closeProgressModal();
                        showMessage('Job was cancelled', 'warning');
                        break;
                    }
                    
                    // Wait before next poll
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                }
            } catch (error) {
                showMessage('Error checking job status: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function renameAllFiles() {
            if (!confirm('This will rename all files in the watched directory based on metadata. Continue?')) {
                return;
            }
            
            showProgressModal('Renaming All Files...');
            
            let successCount = 0;
            let errorCount = 0;
            let totalFiles = 0;
            
            try {
                const response = await fetch('/api/rename-all?stream=true', {
                    method: 'POST'
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                totalFiles = data.results.length;
                                completeProgress();
                                showMessage(`Renamed ${successCount} of ${totalFiles} files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to rename files: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function normalizeAllFiles() {
            if (!confirm('This will normalize metadata for all files in the watched directory. Continue?')) {
                return;
            }
            
            showProgressModal('Normalizing Metadata...');
            
            let successCount = 0;
            let errorCount = 0;
            let totalFiles = 0;
            
            try {
                const response = await fetch('/api/normalize-all?stream=true', {
                    method: 'POST'
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                totalFiles = data.results.length;
                                completeProgress();
                                showMessage(`Normalized metadata for ${successCount} of ${totalFiles} files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to normalize metadata: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function processUnmarkedFiles() {
            if (!confirm('This will process all unmarked files in the watched directory. Continue?')) {
                return;
            }
            
            showProgressModal('Processing Unmarked Files...');
            
            let successCount = 0;
            let errorCount = 0;
            let totalFiles = 0;
            
            try {
                const response = await fetch('/api/process-unmarked?stream=true', {
                    method: 'POST'
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                totalFiles = data.results.length;
                                completeProgress();
                                showMessage(`Processed ${successCount} of ${totalFiles} unmarked files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to process unmarked files: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function renameUnmarkedFiles() {
            if (!confirm('This will rename all unmarked files in the watched directory based on metadata. Continue?')) {
                return;
            }
            
            showProgressModal('Renaming Unmarked Files...');
            
            let successCount = 0;
            let errorCount = 0;
            let totalFiles = 0;
            
            try {
                const response = await fetch('/api/rename-unmarked?stream=true', {
                    method: 'POST'
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                totalFiles = data.results.length;
                                completeProgress();
                                showMessage(`Renamed ${successCount} of ${totalFiles} unmarked files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to rename unmarked files: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function normalizeUnmarkedFiles() {
            if (!confirm('This will normalize metadata for all unmarked files in the watched directory. Continue?')) {
                return;
            }
            
            showProgressModal('Normalizing Metadata for Unmarked Files...');
            
            let successCount = 0;
            let errorCount = 0;
            let totalFiles = 0;
            
            try {
                const response = await fetch('/api/normalize-unmarked?stream=true', {
                    method: 'POST'
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                totalFiles = data.results.length;
                                completeProgress();
                                showMessage(`Normalized metadata for ${successCount} of ${totalFiles} unmarked files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to normalize metadata for unmarked files: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function processSelectedFiles() {
            if (selectedFiles.size === 0) {
                showMessage('No files selected', 'error');
                return;
            }
            
            if (!confirm(`This will process ${selectedFiles.size} selected file${selectedFiles.size > 1 ? 's' : ''}. Continue?`)) {
                return;
            }
            
            showProgressModal('Processing Selected Files...');
            
            const files = Array.from(selectedFiles);
            let successCount = 0;
            let errorCount = 0;
            
            try {
                const response = await fetch('/api/process-selected?stream=true', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: files
                    })
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                completeProgress();
                                showMessage(`Processed ${successCount} of ${files.length} files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to process files: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function renameSelectedFiles() {
            if (selectedFiles.size === 0) {
                showMessage('No files selected', 'error');
                return;
            }
            
            if (!confirm(`This will rename ${selectedFiles.size} selected file${selectedFiles.size > 1 ? 's' : ''} based on metadata. Continue?`)) {
                return;
            }
            
            showProgressModal('Renaming Selected Files...');
            
            const files = Array.from(selectedFiles);
            let successCount = 0;
            let errorCount = 0;
            
            try {
                const response = await fetch('/api/rename-selected?stream=true', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: files
                    })
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                completeProgress();
                                showMessage(`Renamed ${successCount} of ${files.length} files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to rename files: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function normalizeSelectedFiles() {
            if (selectedFiles.size === 0) {
                showMessage('No files selected', 'error');
                return;
            }
            
            if (!confirm(`This will normalize metadata for ${selectedFiles.size} selected file${selectedFiles.size > 1 ? 's' : ''}. Continue?`)) {
                return;
            }
            
            showProgressModal('Normalizing Metadata for Selected Files...');
            
            const files = Array.from(selectedFiles);
            let successCount = 0;
            let errorCount = 0;
            
            try {
                const response = await fetch('/api/normalize-selected?stream=true', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: files
                    })
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.substring(6));
                            
                            if (data.done) {
                                completeProgress();
                                showMessage(`Normalized metadata for ${successCount} of ${files.length} files successfully!`, 'success');
                                // Refresh file list (force refresh to clear cache)
                                await loadFiles(1, true);
                            } else {
                                if (data.success) {
                                    successCount++;
                                } else {
                                    errorCount++;
                                }
                                updateProgress(data.current, data.total, successCount, errorCount);
                                addProgressDetail(data.file, data.success, data.error);
                            }
                        }
                    }
                }
            } catch (error) {
                showMessage('Failed to normalize metadata: ' + error.message, 'error');
                closeProgressModal();
            }
        }
        
        async function processSingleFile(filepath) {
            if (!confirm(`Process ${filepath}?`)) {
                return;
            }
            
            showMessage('Processing file...', 'info');
            
            try {
                const response = await fetch(`/api/process-file/${encodeURIComponent(filepath)}`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('File processed successfully!', 'success');
                    await loadFiles(currentPage, true);
                } else {
                    showMessage(result.error || 'Failed to process file', 'error');
                }
            } catch (error) {
                showMessage('Failed to process file: ' + error.message, 'error');
            }
        }
        
        async function renameSingleFile(filepath) {
            if (!confirm(`Rename ${filepath} based on metadata?`)) {
                return;
            }
            
            showMessage('Renaming file...', 'info');
            
            try {
                const response = await fetch(`/api/rename-file/${encodeURIComponent(filepath)}`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('File renamed successfully!', 'success');
                    await loadFiles(currentPage, true);
                } else {
                    showMessage(result.error || 'Failed to rename file', 'error');
                }
            } catch (error) {
                showMessage('Failed to rename file: ' + error.message, 'error');
            }
        }
        
        async function normalizeSingleFile(filepath) {
            if (!confirm(`Normalize metadata for ${filepath}?`)) {
                return;
            }
            
            showMessage('Normalizing metadata...', 'info');
            
            try {
                const response = await fetch(`/api/normalize-file/${encodeURIComponent(filepath)}`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('Metadata normalized successfully!', 'success');
                    await loadFiles(currentPage, true);
                } else {
                    showMessage(result.error || 'Failed to normalize metadata', 'error');
                }
            } catch (error) {
                showMessage('Failed to normalize metadata: ' + error.message, 'error');
            }
        }
        
        async function deleteSingleFile(filepath) {
            if (!confirm(`Are you sure you want to delete ${filepath}?\n\nThis action cannot be undone!`)) {
                return;
            }
            
            showMessage('Deleting file...', 'info');
            
            try {
                const response = await fetch(`/api/delete-file/${encodeURIComponent(filepath)}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('File deleted successfully!', 'success');
                    await loadFiles(currentPage, true);
                } else {
                    showMessage(result.error || 'Failed to delete file', 'error');
                }
            } catch (error) {
                showMessage('Failed to delete file: ' + error.message, 'error');
            }
        }
        
        function refreshFiles() {
            showMessage('Refreshing file list...', 'info');
            loadFiles(currentPage, true);
        }
        
        function showMessage(message, type = 'info') {
            const container = document.getElementById('messageContainer');
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            messageEl.textContent = message;
            
            container.appendChild(messageEl);
            
            setTimeout(() => {
                messageEl.remove();
            }, 5000);
        }
        
        async function openSettings() {
            try {
                // Load filename format
                const formatResponse = await fetch('/api/settings/filename-format');
                const formatData = await formatResponse.json();
                
                document.getElementById('filenameFormat').value = formatData.format || '';
                document.getElementById('currentFormat').textContent = formatData.format || formatData.default;
                
                // Load current theme
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                document.getElementById('themeSelect').value = currentTheme;
                
                // Load watcher status
                const watcherResponse = await fetch('/api/settings/watcher-enabled');
                const watcherData = await watcherResponse.json();
                document.getElementById('watcherToggleCheckbox').checked = watcherData.enabled;
                
                // Load log max size
                const logResponse = await fetch('/api/settings/log-max-bytes');
                const logData = await logResponse.json();
                document.getElementById('logMaxSize').value = Math.round(logData.maxMB);
                
                document.getElementById('settingsModal').classList.add('active');
            } catch (error) {
                showMessage('Failed to load settings: ' + error.message, 'error');
            }
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }
        
        async function openLogsModal() {
            document.getElementById('logsModal').classList.add('active');
            await loadLogs();
        }
        
        function closeLogsModal() {
            document.getElementById('logsModal').classList.remove('active');
        }
        
        async function openAboutModal() {
            try {
                // Load version
                const response = await fetch('/api/version');
                const data = await response.json();
                const aboutVersionElement = document.getElementById('aboutVersion');
                if (aboutVersionElement && data.version) {
                    aboutVersionElement.textContent = `v${data.version}`;
                }
                
                document.getElementById('aboutModal').classList.add('active');
            } catch (error) {
                showMessage('Failed to load version information: ' + error.message, 'error');
            }
        }
        
        function closeAboutModal() {
            document.getElementById('aboutModal').classList.remove('active');
        }
        
        function showProgressModal(title) {
            const modal = document.getElementById('progressModal');
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressBarFill').style.width = '0%';
            document.getElementById('progressText').textContent = '0 / 0 files';
            document.getElementById('progressPercent').textContent = '0%';
            document.getElementById('progressDetails').innerHTML = '';
            document.getElementById('progressCloseBtn').style.display = 'none';
            modal.classList.add('active');
        }
        
        function updateProgress(current, total, successCount, errorCount) {
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;
            document.getElementById('progressBarFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = `${current} / ${total} files`;
            document.getElementById('progressPercent').textContent = percent + '%';
            
            // Update title with success/error counts if any errors
            let title = 'Processing Files...';
            if (errorCount > 0) {
                title = `Processing Files - ${successCount} succeeded, ${errorCount} failed`;
            }
            document.getElementById('progressTitle').textContent = title;
        }
        
        function addProgressDetail(filename, success, error = null) {
            const details = document.getElementById('progressDetails');
            const entry = document.createElement('div');
            entry.style.marginBottom = '5px';
            
            if (success) {
                entry.innerHTML = `✅ ${filename}`;
                entry.style.color = '#2ecc71';
            } else {
                entry.innerHTML = `❌ ${filename}${error ? ': ' + error : ''}`;
                entry.style.color = '#e74c3c';
            }
            
            details.appendChild(entry);
            details.scrollTop = details.scrollHeight;
        }
        
        function completeProgress() {
            document.getElementById('progressCloseBtn').style.display = 'block';
        }
        
        function closeProgressModal() {
            document.getElementById('progressModal').classList.remove('active');
        }
        
        async function loadLogs() {
            const logsContent = document.getElementById('logsContent');
            const logsLoadingIndicator = document.getElementById('logsLoadingIndicator');
            const logStats = document.getElementById('logStats');
            const lines = document.getElementById('logLines').value;
            
            try {
                logsLoadingIndicator.style.display = 'block';
                logsContent.textContent = '';
                logStats.textContent = '';
                
                const response = await fetch(`/api/logs?lines=${lines}`);
                const data = await response.json();
                
                if (data.error) {
                    logsContent.textContent = 'Error: ' + data.error;
                } else {
                    logsContent.textContent = data.logs || 'No logs available';
                    logStats.textContent = `Showing ${data.returned_lines} of ${data.total_lines} total lines`;
                }
            } catch (error) {
                logsContent.textContent = 'Failed to load logs: ' + error.message;
            } finally {
                logsLoadingIndicator.style.display = 'none';
            }
        }
        
        async function saveFilenameFormat() {
            const format = document.getElementById('filenameFormat').value.trim();
            const logMaxSize = parseFloat(document.getElementById('logMaxSize').value);
            
            if (!format) {
                showMessage('Filename format cannot be empty', 'error');
                return;
            }
            
            if (isNaN(logMaxSize) || logMaxSize <= 0) {
                showMessage('Log max size must be a positive number', 'error');
                return;
            }
            
            try {
                // Save filename format
                const formatResponse = await fetch('/api/settings/filename-format', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ format: format })
                });
                
                const formatResult = await formatResponse.json();
                
                if (!formatResult.success) {
                    showMessage(formatResult.error || 'Failed to save filename format', 'error');
                    return;
                }
                
                // Save log max size
                const logResponse = await fetch('/api/settings/log-max-bytes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ maxMB: logMaxSize })
                });
                
                const logResult = await logResponse.json();
                
                if (!logResult.success) {
                    showMessage(logResult.error || 'Failed to save log max size', 'error');
                    return;
                }
                
                showMessage('Settings saved successfully! Log rotation will take effect on restart.', 'success');
                closeSettings();
            } catch (error) {
                showMessage('Failed to save settings: ' + error.message, 'error');
            }
        }
        
        async function resetFilenameFormat() {
            try {
                const response = await fetch('/api/settings/filename-format');
                const data = await response.json();
                
                document.getElementById('filenameFormat').value = data.default;
                showMessage('Reset to default format', 'info');
            } catch (error) {
                showMessage('Failed to reset format: ' + error.message, 'error');
            }
        }
        
        function toggleDropdown(event, filepath) {
            event.stopPropagation();
            
            const dropdownId = 'dropdown-' + filepath.replace(/[^a-zA-Z0-9]/g, '_');
            const dropdown = document.getElementById(dropdownId);
            
            // Close all other dropdowns
            document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
                if (menu.id !== dropdownId) {
                    menu.classList.remove('show');
                }
            });
            
            // Toggle this dropdown
            dropdown.classList.toggle('show');
        }
        
        function closeAllDropdowns() {
            document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
                menu.classList.remove('show');
            });
            // Also close filter dropdown
            const filterMenu = document.getElementById('filterDropdownMenu');
            if (filterMenu) {
                filterMenu.classList.remove('show');
            }
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.file-actions-dropdown')) {
                closeAllDropdowns();
            }
            // Close header filter dropdown when clicking outside
            if (!event.target.closest('.header-filter-dropdown')) {
                const filterMenu = document.getElementById('headerFilterMenu');
                if (filterMenu) {
                    filterMenu.classList.remove('show');
                }
            }
            // Close header sort dropdown when clicking outside
            if (!event.target.closest('.header-sort-dropdown')) {
                const sortMenu = document.getElementById('headerSortMenu');
                if (sortMenu) {
                    sortMenu.classList.remove('show');
                }
            }
            // Close settings dropdown when clicking outside
            if (!event.target.closest('.settings-menu-wrapper')) {
                const settingsMenu = document.getElementById('settingsDropdownMenu');
                if (settingsMenu) {
                    settingsMenu.classList.remove('show');
                }
            }
        });
    </script>
</body>
</html>
